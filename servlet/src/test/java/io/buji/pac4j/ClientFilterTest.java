/*
 * Licensed to the bujiio organization of the Shiro project under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package io.buji.pac4j;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.doReturn;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.verifyStatic;
import static org.powermock.api.mockito.PowerMockito.whenNew;

import java.io.IOException;

import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

import org.apache.shiro.SecurityUtils;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.web.filter.authc.AuthenticationFilter;
import org.apache.shiro.web.util.WebUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.pac4j.core.client.Clients;
import org.pac4j.core.client.IndirectClient;
import org.pac4j.core.context.J2EContext;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import com.openpojo.reflection.impl.PojoClassFactory;
import com.openpojo.validation.Validator;
import com.openpojo.validation.ValidatorBuilder;
import com.openpojo.validation.test.impl.GetterTester;

/**
 * ClientFilter.java test coverage class
 *
 * @author Furkan Yavuz
 * @since 1.4.2
 */
@RunWith(PowerMockRunner.class)
@PrepareForTest({ ClientFilter.class, AuthenticationFilter.class, WebUtils.class, SecurityUtils.class })
public class ClientFilterTest {
	
	private ClientFilter clientFilter;
	private ServletRequest servletRequestMock;
	private ServletResponse servletResponseMock;


	@Before
	public void setUp() throws Exception {
		servletRequestMock = mock(ServletRequest.class);
		servletResponseMock = mock(ServletResponse.class);
		
		clientFilter = new ClientFilter();
		
		mockStatic(WebUtils.class);
		mockStatic(SecurityUtils.class);
	}

	@SuppressWarnings("rawtypes")
	@Test
	public final void testCreateToken() throws Exception {
		// given
		String clientName = "CLIENT_NAME";
		IndirectClient clientMock = mock(IndirectClient.class);
		Clients clientsMock  = mock(Clients.class);
		clientFilter.setClients(clientsMock);
		
		J2EContext j2EContextMock = mock(J2EContext.class);
		whenNew(J2EContext.class).withAnyArguments().thenReturn(j2EContextMock);
		
		doReturn(clientName).when(clientMock).getName();
		doReturn(clientMock).when(clientsMock).findClient(j2EContextMock);
		
		// when
		ClientToken clientToken = (ClientToken) clientFilter.createToken(servletRequestMock, servletResponseMock);
		
		// then
		assertEquals("Client token generated by using clientMock therefore client token's client name must be equal to " + clientName, clientName, clientToken.getClientName());
		
	}

	@SuppressWarnings("rawtypes")
	@Test
	public final void testOnAccessDenied() throws Exception {
		// given
		Subject subjectMock = mock(Subject.class);
		doReturn(subjectMock).when(SecurityUtils.class);
		SecurityUtils.getSubject();

		String clientName = "CLIENT_NAME";
		IndirectClient clientMock = mock(IndirectClient.class);
		Clients clientsMock  = mock(Clients.class);
		clientFilter.setClients(clientsMock);
		
		J2EContext j2EContextMock = mock(J2EContext.class);
		whenNew(J2EContext.class).withAnyArguments().thenReturn(j2EContextMock);
		
		doReturn(clientName).when(clientMock).getName();
		doReturn(clientMock).when(clientsMock).findClient(j2EContextMock);

		// when
		boolean result = clientFilter.onAccessDenied(servletRequestMock, servletResponseMock);
		
		// then
		assertFalse("redirectAfterSuccessfulAuthentication field set to true therefore result must be true", result);
	}

	@Test
	public final void testIsAccessAllowed() {
		// when
		boolean result = clientFilter.isAccessAllowed(null, null, null);
		
		// then
		assertFalse("Logically, result must be false", result);
	}

	@Test
	public final void testOnLoginSuccessRedirectAfterSuccessfulAuthenticationFalse() throws Exception {
		// given
		clientFilter.setRedirectAfterSuccessfulAuthentication(false);
		
		// when
		boolean result = clientFilter.onLoginSuccess(null, null, servletRequestMock, servletResponseMock);
		
		// then
		assertTrue("redirectAfterSuccessfulAuthentication field set to false therefore result must be true", result);
	}

	@Test
	public final void testOnLoginSuccessRedirectAfterSuccessfulAuthenticationTrue() throws Exception {
		// given
		clientFilter.setRedirectAfterSuccessfulAuthentication(true);
		
		// when
		boolean result = clientFilter.onLoginSuccess(null, null, servletRequestMock, servletResponseMock);
		
		// then
		assertFalse("redirectAfterSuccessfulAuthentication field set to true therefore result must be true", result);
	}

	@Test
	public final void testOnLoginFailureAuthenticatedTrue() throws IOException {
		// given
		Subject subjectMock = mock(Subject.class);
		doReturn(subjectMock).when(SecurityUtils.class);
		SecurityUtils.getSubject();
		
		doReturn(true).when(subjectMock).isAuthenticated();
		
		// when
		clientFilter.onLoginFailure(null, null, servletRequestMock, servletResponseMock);
		
		// then
		verifyStatic();
		WebUtils.redirectToSavedRequest(servletRequestMock, servletResponseMock, AuthenticationFilter.DEFAULT_SUCCESS_URL);
	}
	
	@Test
	public final void testOnLoginFailureAuthenticatedFalse() throws IOException {
		// given
		Subject subjectMock = mock(Subject.class);
		doReturn(subjectMock).when(SecurityUtils.class);
		SecurityUtils.getSubject();
		String failureUrl = "FAILURE_URL";
		clientFilter.setFailureUrl(failureUrl);
		
		doReturn(false).when(subjectMock).isAuthenticated();
		
		// when
		clientFilter.onLoginFailure(null, null, servletRequestMock, servletResponseMock);
		
		// then
		verifyStatic();
		WebUtils.issueRedirect(servletRequestMock, servletResponseMock, failureUrl);
	}

	@Test
	public final void testGetterSetter() throws Exception {
		Validator validator = ValidatorBuilder.create().with(new GetterTester()).build();
		validator.validate(PojoClassFactory.getPojoClass(ClientFilter.class));
		
		// setter functions validation
		clientFilter.setRedirectAfterSuccessfulAuthentication(true);
		assertTrue(clientFilter.getRedirectAfterSuccessfulAuthentication());
		
		String failureUrl = "FAIL_URL";
		clientFilter.setFailureUrl(failureUrl);
		assertEquals(failureUrl, clientFilter.getFailureUrl());
		
		Clients clientsMock = mock(Clients.class);
		clientFilter.setClients(clientsMock);
		verify(clientsMock).init();
	}
}
